<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>BusTub Lab1 Buffer Pool Manager | Fischer&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="BusTub Lab1 Buffer Pool Manager Task1 可扩展哈希表 相关函数 Find(K,V)​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回fal">
<meta name="author" content="Sulv">
<link rel="canonical" href="http://itfischer.space/en/posts/tech/bustub/bustub-lab1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://itfischer.space/img/Navigation.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://itfischer.space/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="http://itfischer.space/img/Q.gif">
<link rel="apple-touch-icon" href="http://itfischer.space/Q.gif">
<link rel="mask-icon" href="http://itfischer.space/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="BusTub Lab1 Buffer Pool Manager" />
<meta property="og:description" content="BusTub Lab1 Buffer Pool Manager Task1 可扩展哈希表 相关函数 Find(K,V)​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回fal" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://itfischer.space/en/posts/tech/bustub/bustub-lab1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-20T14:54:39+00:00" />
<meta property="article:modified_time" content="2023-03-24T16:40:47+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BusTub Lab1 Buffer Pool Manager"/>
<meta name="twitter:description" content="BusTub Lab1 Buffer Pool Manager Task1 可扩展哈希表 相关函数 Find(K,V)​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回fal"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "http://itfischer.space/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tech",
      "item": "http://itfischer.space/en/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Bustub通关指南",
      "item": "http://itfischer.space/en/posts/tech/bustub/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "BusTub Lab1 Buffer Pool Manager",
      "item": "http://itfischer.space/en/posts/tech/bustub/bustub-lab1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BusTub Lab1 Buffer Pool Manager",
  "name": "BusTub Lab1 Buffer Pool Manager",
  "description": "BusTub Lab1 Buffer Pool Manager Task1 可扩展哈希表 相关函数 Find(K,V)​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回fal",
  "keywords": [
    
  ],
  "articleBody": "BusTub Lab1 Buffer Pool Manager Task1 可扩展哈希表 相关函数 Find(K,V)​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回false\nInsert(K,V):插入一个值，如果已经存在，则覆盖原本的值，返回true，如果当前k-v不能被插入（bucket满了，并且不是对原有的key进行更新），则：\n如果局部深度（容量）等于全局深度，增加全局深度，并且对dict的容量翻倍 增加当前要插入的bucket的深度 分裂当前的bucket，对其进行rehash 之后再进行重试，在此Lab当中，在插入之前进行容量的检测并进行rehash\nRemove(K):删除给定的Key，存在则返回true，否则返回false\nGetGlobalDepth():返回全局深度\nGetNumBuckets():返回当前存在的bucket的总量\nHint：\n可以使用IndexOf(K)​来求出当前Key所属的bucket Bucket作为一个内嵌类之于HashTable 保证线程安全，使用std::mutex 实现 逻辑上较为清晰，首先实现Bucket类，在KV的管理上，需要实现Find、Insert、Remove操作，并且需要有一系列获取相关信息的操作，\nBucket本身是由一个链表进行组织的，实现上直接调用std::list的API即可\n主要讨论一下Hash过程\n对于可扩展哈希，主要有四个变量：\nsize_dir_：表示整个目录的大小，扩展时进行翻倍 size_bucket_：一个bucket中能够存放的最大的元素，为固定值 global_depth：根据global_depth的位数将key hash到对应的bucket当中 local_depth：在bucket split时使用local_depth进行rehash 在引入了深度的概念之后，由于可扩展哈希分为bucket和bucket当中的元素，对应的就有全局深度和本地深度的区分，如果全局深度为2，则证明当前至多只能有4个Bucket，（而实际的bucket数量可能并没有4个，存在多个dir指向同一个bucket的情况）而如果本地深度为2，则下次bucket进行分裂时，使用local_depth +1​位进行rehash(如果认为最右一位为第1位，实际上只需要将1左移local_depth位即可）\n在搜索时，先根据global_depth​找到所属的bucket，再在bucket其中遍历寻找到元素\n明确了概念之后，可以捋一下整个过程：\n尝试向其中插入[0,1,2,3,4,5]\n当bucket满了时：\n如果局部深度（容量）等于全局深度，增加全局深度，并且对dict的容量翻倍 增加当前要插入的bucket的深度 分裂当前的bucket，对其进行rehash 最初在初始化时，global_depth = 0​ local_depth = 0​,此时只有一个bucket，并且当中能够存放一个元素 之后向其中插入元素1，而此时bucket当中有两个元素，需要对其进行区分，(触发了全局深度等于本地深度的条件)，因此：\n增加全局深度，global_depth = 1​,bucket数量翻倍 增加本地深度，local_depth = 1​ rehash 说一下最后的rehash的过程，虽然此时local_depth = 1​，但是在gloabal_depth=1​的条件下，hash码01无法定位到0号bucket，因此需要对其进行rehash\n此时再向其中插入2（10），global_depth = 1​因此会被rehash到0号bucket当中，而0号bucket并未满，因此可以将其插入到其中，3（11）同理，结果如下：\n再向其中插入4(100),在global_depth = 1​的条件下被分配到0号bucket，而此时bucket0已满，按照上面的要求步骤对bucket0再split一次，插入后的结果如下：\n插入5和4同理，将bucket1进行split,最终结果如下：\n还有一点需要讨论的是，并不是通过gloal_depth​ + local_depth​对key给进行定位，对于global_depth​，既是代表当前的dir数量，2则代表有00 01 10 11四个bucket，并且对于一个哈希码，确实可以通过global_depth​位就将其归于属于的bucket当中，但是对于local_depth​，仅仅只是在split时用于将当前bucket中的元素和新插入的元素rehash到不同的bucket当中，即与key的搜索无关，也与bucket的容量无关。\n对于local_depteh \u003c global_depth的bucket，会存在多个dir指向同一个bucket的情况，当local_depth = global_depth时，则只会有一个dir指向该bucket。\n而在bucket split时，通过local_depth来决定元素都属于哪一个新的bucket当中。即将1左移local_depth位，即为local_mask，hash该位为1的归于一个bucket当中,为0的归于一个bucket当中。\n之后再去考虑两个新的bucket均需要属于哪个dir，上一步位与为0应当对应原本的dir[i]，而另外一个应当为dir[i+local_mask]。因此现在所做的就是需要找到i为多少，计算hash值然后取local_depth位，再与local_mask位与，结果为0即为low_bucket,为1即为high_bucket。\n此外需要考虑连续分裂的问题，如[0 1024 4]进行一次split不足以将这三者区分开，因此一种解决方法是在split最后调用extendiable_hash_table中的Insert，而不是调用bucket的insert，让哈希表的Insert再去判断一遍是否还需要分裂，不过这样嵌套调用无法使用RAII类型的锁，需要手动去加锁解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u003ctypename K, typename V\u003e void ExtendibleHashTable::Insert(const K \u0026key, const V \u0026value) { //std::scoped_lock lock(latch_); latch_.lock(); auto index = IndexOf(key); auto bucket = this-\u003edir_[index]; bool result = bucket-\u003eInsert(key, value); if (result) { latch_.unlock(); return; } RedistributeBucket(bucket,key,value); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template \u003ctypename K, typename V\u003e auto ExtendibleHashTable::RedistributeBucket(std::shared_ptr bucket,const K \u0026key,const V \u0026value) -\u003e void { if (!bucket-\u003eIsFull()) { latch_.unlock(); return; } if (bucket-\u003eGetDepth() == this-\u003eGetGlobalDepthInternal()) { auto size = dir_.size(); dir_.reserve(size * 2); std::copy_n(dir_.begin(),size,std::back_inserter(dir_)); this-\u003eglobal_depth_++; } auto last_depth = bucket-\u003eGetDepth(); auto high_bucket = std::make_shared(bucket_size_,last_depth + 1); auto low_bucket = std::make_shared(bucket_size_,last_depth + 1); num_buckets_++; int local_mask = 1 \u003c\u003c last_depth; for (const auto \u0026[k,v] : bucket-\u003eGetItems()) { if (std::hash()(k) \u0026 local_mask) { high_bucket-\u003eInsert(k,v); } else { low_bucket-\u003eInsert(k,v); } } for (auto i = std::hash()(key) \u0026 (local_mask - 1);i \u003c dir_.size();i += local_mask) { if (static_cast\u003cbool\u003e (i \u0026 local_mask)) { dir_[i] = high_bucket; } else { dir_[i] = low_bucket; } } //auto new_index = IndexOf(key); latch_.unlock(); this-\u003eInsert(key,value); } 在实现上先实现Bucket即可，先将Bucket设置为无锁的类型，再整个HashTable上加一把大锁，后续再考虑进行改进，以提高并发度\nTask2 LRU-K 在淘汰时选择Backward k-distance最大的进行淘汰，Backword-distance使用当前的时间戳和第前K次访问的时间戳进行计算，还未达到K次访问的Backword-distance记为正无穷，而当有多个正无穷时，则选择最早的时间戳进行淘汰。\nLRUKReplacer​和BufferPool​的大小一致，但是任何时刻下并不是所有page都会去考虑被淘汰，\n相关函数 Evict(frame_id_t*):在被Replacer记录的所有的可淘汰的frame中选择Backward k-distance最大的那一个，在参数中保存淘汰page的Id，返回true，如果没有可淘汰的frame则返回false RecordAccess(frame_id_t)​：基于当前的时间戳，记录给定的frameid，当一个page被BufferPoolManager​pin时调用 Remove(frame_id_t)​：清除一个frame的所有相关历史，当page被删除时调用 SetEvictable(frame_id_t,bool set_evictable)​：标记一个frame是否可清理 Size()​返回可清除的frame的数量。 实现 相关概念 LRU-K所针对的为缓存污染的问题，即遇到全表遍历等大量读取多个不重复的page时，如果使用LRU会将当前缓存中的所有的page全部淘汰掉，从而造成缓存失效的问题。\n在LRU-K中，主要的淘汰依据为backword k-distance​​，即据K次访问前的距离，\n而此处的距离作为时间的抽象，访问时间距离当前越久则为时间越长。而前K次访问的距离则是前K次访问的时间，可以用时间戳来表示 而对于访问次数还未到K次的情况，则是将其记为+inf，即正无穷 当进行淘汰时，选择backword k-distance​最大的frame进行淘汰 因此，由于还未访问到K次的frame会被记为正无穷，因此淘汰时会选择还未访问到k次的进行淘汰，而如果存在多个访问还不到K次的frame，则该几个frame之间使用普通的LRU进行淘汰，比较上一次的访问时间，其实即为k = 1的情况。\n而如果全部为访问了K次以及以上的frame，那么则选择distance最大的进行淘汰。\n目前能够想到的方案就是对于frame使用一个map来管理，而对每个frame封装一个frameInfo，在其中维护如是否为+inf，一次一个长度为K的链表，记录前K次的访问时间。但是这样的问题就是每次淘汰frame时需要遍历整个map，统计出K次访问最久远的frame，无法想LRU那样在O(1)的时间复杂度完成get/put。\n时间戳可使用自增的id即可。\n此外还有一个概念，BufferPool和LRU-K Replacer当中存储的为frame​，在BufferPool当中，应当预先初始化好一定的frame，之后frame的数量一直不变，每个frame对应一个frame_id，任何大于总容量的frame_id均为非法的frame_id。在replacer当中定义一个replacer_size，其大小应当和buffer_pool的size大小相同，同样对违法的frame_id进行检测\n实现 单HashMap内嵌List\n说清楚了相关概念，就再说一下如何实现，我主要想到了两种实现方案，第一种是上述的FrameInfo​，然后在一个HashMap当中去管理所有的FrameInfo，定义如下：\n1 2 3 4 5 6 struct FrameInfo{ bool isInf{true}; bool evictable{true}; std::deque access_timestamp_; FrameInfo() = default; }; isInf​表示当前是否已经被访问了K次，如果还未，则设置为true，之后进行淘汰时优先淘汰还未访问K次的frame，当到达K次之后再设置为false。\nevictable​​表示当前的frame是否能被淘汰，用于在bufferpool当中pin住一些page，同时evictable​​也决定当前replacer的size。\ndeque​表示当前的该frame被访问的时间戳，大小上限为K，只保存K次以内的情况（不知道为什么用list就插入不进去，最后选择了deque，c++学太烂了先不管了）\n在这种实现方式下就不怎么分历史队列和缓冲队列了，反正历史队列和缓冲队列本身都要要存入bufferPool当中的，不如直接统一管理\nRecord_access：添加一次访问记录时首先判断之前是否访问过，如果访问过则找到之前的访问记录，则在尾部添加一条新的，注意是否超过K次取消掉+inf和超过K次之后把最早的删除掉即可，如果之前没有相关记录则直接新建一条即可\nRemove、Size、SetEvictable的实现较为简单，按照注释完成即可\nEvict：按照LRU-K原本的定义，应当先遍历历史队列，如果当中有frame的访问历史记录，则从历史队列中删除，历史队列当中如果没有能够可以淘汰的再选择从缓存队列中进行淘汰。因此对整个FrameInfo Map进行遍历，\n标记所有的inf，记录最小的时间戳，同时也记录访问了K次的，记录最小的时间戳，最终如果找到过inf的，则选择inf的进行淘汰，否则淘汰访问了K次的，注意跳过non-evictable​即可，弄清楚了LRU-K的概念之后实现起来就没有什么难度了。\n双List+单HashMap​\n这种方式则使用将历史记录和缓存分别使用两个List管理，之后删除是先遍历历史记录的List，如果找不到可以删除的，则再遍历缓存的List，\n在添加一次新的访问时，如果之前毫无记录，则将其添加到历史记录当中，并使用HashMap存储记录当前的迭代器位置和所属的队列， 如果访问次数i 1\u003c i \u003c k​,由于比较的是最早的访问时间，因此什么都不用做 如果访问次数到达K次，则将其移入到缓冲队列当中，更新Map当中相关的迭代器和所属队列 如果超过K次，则将其移入到缓冲队列的尾部，淘汰时从头部开始进行淘汰，更新迭代器 当淘汰时则先遍历历史队列，寻找第一个evictable​的frame进行淘汰，如果找不到，再去缓冲队列当中去寻找。\n严格来说这种实现方法更符合LRU-K原本的定义，这样如果不考虑 evictable​所带来的额外比较，在evict remove时的时间复杂度为O(1)，而之前那种实现方式需要遍历整个Map因此为常数复杂度，等有空考虑重构优化一下。\n本身也没有什么线程安全问题，各个函数直接一个区域锁利用 RAII保平安。\nTask3 Buffer Pool Manager Instance 从磁盘当中去读取page存储到内存当中，当Buffer Pool满了之后，再使用LRU-K将page从内存中淘汰，写回到硬盘上。\n内存中的Page使用Page​对象进行抽象，buffer pool无需关心page当中的内容，page当中包含一块内存，对应一个物理页，之后将对应的内存上的内容写入到硬盘上，一个Page​对应一个物理页，通过page_id​进行表述，如果该page没有对应的物理页，则page_id为INVALID_PAGE_ID​\nPage当中需要有一个计数器记录有多少个线程pinned​了该page，对于被pinned​的page，不允许将其释放，page需要记录是否为dirty​，如果非dirty​则淘汰时不需要回写硬盘，而dirty​的page需要先回写再重新使用\n使用之前的ExtendiableHashTable​进行page_id到frame_id的映射，使用LRUKReplacer​来记录各个page的使用情况\nFetchPgImp(page_id)​：如果没有可用的page并且其他的page全部被pinned​了,返回nullptr UnpinPgImp(page_id, is_dirty)​ FlushPgImp(page_id)​：不管是否被pin，都将page给刷盘 NewPgImp(page_id)​：AllocatePage​用于生成一个唯一的PageId，DeallocatePage​ 模拟将page刷盘到硬盘上，在DeletePgImp当中调用 DeletePgImp(page_id)​ FlushAllPagesImpl()​​ 实现 Buffer Pool的整体实现并不难，首先描述一下整个Buffer Pool的物理结构，Buffer Pool当中的容器或者说page的载体为frame，所有的frame本身是不变的，即frame的数量即为Buffer Pool的大小，在Buffer Pool进行初始化时，初始化一个Frame数组，其中每一个元素及对应着一个Frame，数组的下表即为Frame_id，如果page为尚未初始化的状态，则代表该frame当中还未存放元素，当有一个Page要受到Buffer Pool管理时，则对该Page进行初始化，设置对应的PageId和元数据 以及Page当中存储的数据设置到该Page当中。\n除此之外还有Buffer Pool的管理数据结构，即前两个task所实现的可扩展哈希表和LRU-K Replacer，以及一个用于记录空frame的链表\n当一个Page要加入到Buffer Pool当中，无论是新建一个Page还是从硬盘当中读取一个Page，首先先尝试从空frame链表当中获取一个frame_id，之后在Page数组当中对其进行初始化，而如果空闲链表当中没有额外的frame_id去分配，则证明当前的Buffer Pool已满，因此需要尝试通过LRU-K去淘汰一个当前Page的，获取一个新的Page，为了流程的统一，就淘汰之后再将frame加入到空闲链表当中，之后再从空闲链表当中尝试去获取一个Page。将新的Page重新让Replacer和page_table去管理。\n以NewPage为例，大致架构如下：\n搞清楚了整体架构再实现起来就比较方便了，这里就简单解释一下几个函数的相关作用,\nNewPage：即为上层需要创建一个新的Page用于存储新的数据，如在Insert时进行调用，即按照上图的步骤完成即可，先后尝试从free_list_​,若不能则告知replacer​进行淘汰，再从free_list_​当中进行获取，最后创建Page，并Page交给BufferPool管理。\n此外，创建Page即代表上层需要一个Page来承载数据，即当前需要使用该Page，因此需要该Page驻留在Buffer Pool当中，因此创建之后应当pin​住它，即修改pin_count_​和evictable​。\n由于涉及修改好几个数据结构，因此做了一个封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto BufferPoolManagerInstance::CreateNewPage(frame_id_t empty_frame_id) -\u003e Page * { auto new_page_id = AllocatePage(); Page *new_page = \u0026pages_[empty_frame_id]; ResetPage(new_page, new_page_id); // pin a new page new_page-\u003epin_count_++; AddNewPageToBufferPool(empty_frame_id, new_page_id); return new_page; } auto BufferPoolManagerInstance::AddNewPageToBufferPool(frame_id_t frame_id, page_id_t page_id) -\u003e void { replacer_-\u003eRecordAccess(frame_id); replacer_-\u003eSetEvictable(frame_id, false); page_table_-\u003eInsert(page_id, frame_id); } 通过replacer_​淘汰一个page封装成一个函数，淘汰之后如果为脏页则需要进行Flush刷盘，因为EvictPage​会被加锁的NewPage调用，因此自身并不加锁，而且调用无锁的FlushPage​\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 auto BufferPoolManagerInstance::EvictPage() -\u003e bool { frame_id_t frame_id; bool result = replacer_-\u003eEvict(\u0026frame_id); if (!result) { return false; } // if frame can be evicted,it means page is not pinned; Page *page_to_evict = \u0026pages_[frame_id]; if (page_to_evict-\u003eIsDirty()) { FlushWithoutLock(page_to_evict-\u003eGetPageId()); } free_list_.push_back(frame_id); page_table_-\u003eRemove(page_to_evict-\u003epage_id_); replacer_-\u003eRemove(frame_id); return true; } FetchPage​：在流程上和NewPage​差不多，尝试从Buffer Pool当中获取一个Page，如果page_table_​当中有则证明存在于Buffer Pool当中 ，直接读取返回。而如果没有则分别从free_list_​和replacer​当中尝试找到一个frame​来承载Page，使用disk_manager_​进行读取，然后交给Buffer Pool​管理。\n由于FetchPage​的目的也是去读取一个Page为上层所用，因此同样需要将其pin住，直至使用完。\n此外如果是通过free_list_​和replacer_​所获取的Frame需要先清除上一个Page在其中残留的数据，之后加载新数据，由于grade_scope上传时不会去打包Page.h​，因此不应当对Page.h​进行修改，因此将该函数封装到Buffer Pool当中\n1 2 3 4 5 6 auto BufferPoolManagerInstance::ResetPage(Page *page, page_id_t page_id) -\u003e void { page-\u003eResetMemory(); page-\u003epage_id_ = page_id; page-\u003epin_count_ = 0; page-\u003eis_dirty_ = false; } UnpinPage​：NewPage​和FetchPage​均为获取一个Page，之后为上层所用，因此获取的同时会Pin住该Page，而UnpinPage​即为用于在使用完page之后取消对该page的占用，让其可以被淘汰。\nUnpin​一次则对pin_count_​递减一次，当为0时证明没有任何上层函数在占用该Page，则可以set evictable​，之后replacer​即可对其进行淘汰\n同时UnpinPage​会传入一个is_dirty​，来代表之前占有Page时进行的操作是读操作还是写操作。此外Page上is_diry​的修改会有一定的限制，即如果原本为脏页，那么此次进行的是读操作，那么不能进行修改，需要保持脏页状态。而如果原本非脏页，那么即可随意修改。\nFlushPage​ DeletePage​ FlushAllPage​等逻辑比较简单，按照注释写基本就没什么问题。\ndebug 关于线程安全，保险的方案就是使用一个区域锁锁住整个函数，一把大锁保平安，但是之前写的时候在EvictPage​当中偷懒复用了一下FlushPage​，因此调用前解锁，调用完再加锁，导致了一个中间状态，再解锁的间隙所就被在并发的其他函数（UnpinPage​）抢走了，如果按照事务的说法就是违反了原子性，导致已经pin_count_ = 0​的Page又被其他的线程抢走了重新Unpin​一次\n因此最终选择单独封装了一个无锁版本的FlushWithoutLock​，之后EvictPage​ FlushPage​ FlushAllPage​全部调用该函数。即可保证线程安全，不会出现中间态。\nSummary 整个Buffer Pool的难度并不算大，写完之后也大致感受到了BusTub和6.830的侧重点 相比于6.830 BusTub少了很多dirty work，更注重于核心部分的实现，像表结构，Catalog，和HeapFile统统没有让我去写，而是专注于整个Buffer Pool。\nBuffer Pool 从0开始 可扩展哈希表+LRU-K的实现也有意思很多，相比于6.830的直接无脑一个ConcurrentHashMap，淘汰策略也没有做任何要求，FIFO也能通过测试。\n不过个人感觉刚接触数据库的话6.830可能比较友好一点，能对数据库的各方面都有一定的了解，有些dirty work首先一边体会才更深，例如HeapPage HeapFile里面的一个比较Tricky的位于算和Bit map，445的话就不能光去实现project了，其他地方的源码最好也读一读。\n‍\n",
  "wordCount" : "8556",
  "inLanguage": "en",
  "datePublished": "2023-03-20T14:54:39Z",
  "dateModified": "2023-03-24T16:40:47Z",
  "author":{
    "@type": "Person",
    "name": "Sulv"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://itfischer.space/en/posts/tech/bustub/bustub-lab1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Fischer's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://itfischer.space/img/Navigation.svg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://itfischer.space/en/" accesskey="h" title="Fischer&#39;s Blog (Alt + H)">
                <img src="http://itfischer.space/img/Navigation.svg" alt="" aria-label="logo"
                    height="35">Fischer&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://itfischer.space/en/search" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://itfischer.space/en/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://itfischer.space/en/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://itfischer.space/en/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://itfischer.space/en/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://itfischer.space/en/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://itfischer.space/en/">Home</a>&nbsp;»&nbsp;<a href="http://itfischer.space/en/posts/">Blog</a>&nbsp;»&nbsp;<a href="http://itfischer.space/en/posts/tech/">Tech</a>&nbsp;»&nbsp;<a href="http://itfischer.space/en/posts/tech/bustub/">Bustub通关指南</a></div>
    <h1 class="post-title entry-hint-parent">
      BusTub Lab1 Buffer Pool Manager
    </h1>
    <div class="post-meta"><span title='2023-03-20 14:54:39 +0000 UTC'>2023-03-20</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Sulv

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#bustub-lab1-buffer-pool-manager" aria-label="BusTub Lab1 Buffer Pool Manager">BusTub Lab1 Buffer Pool Manager</a><ul>
                        
                <li>
                    <a href="#task1-%e5%8f%af%e6%89%a9%e5%b1%95%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="Task1 可扩展哈希表">Task1 可扩展哈希表</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0" aria-label="相关函数">相关函数</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a></li></ul>
                </li>
                <li>
                    <a href="#task2-lru-k" aria-label="Task2 LRU-K">Task2 LRU-K</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0-1" aria-label="相关函数">相关函数</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0-1" aria-label="实现">实现</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5" aria-label="相关概念">相关概念</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0-2" aria-label="实现">实现</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#task3-buffer-pool-manager-instance" aria-label="Task3 Buffer Pool Manager Instance">Task3 Buffer Pool Manager Instance</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0-3" aria-label="实现">实现</a></li>
                <li>
                    <a href="#debug" aria-label="debug">debug</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="bustub-lab1-buffer-pool-manager">BusTub Lab1 Buffer Pool Manager<a hidden class="anchor" aria-hidden="true" href="#bustub-lab1-buffer-pool-manager">#</a></h1>
<h2 id="task1-可扩展哈希表">Task1 可扩展哈希表<a hidden class="anchor" aria-hidden="true" href="#task1-可扩展哈希表">#</a></h2>
<h3 id="相关函数">相关函数<a hidden class="anchor" aria-hidden="true" href="#相关函数">#</a></h3>
<ul>
<li>
<p><code>Find(K,V)</code>​：查询一个Key是否存在，如果存在则将其V指针指向相关的值，返回true，否则返回false</p>
</li>
<li>
<p><code>Insert(K,V)</code>:插入一个值，如果已经存在，则覆盖原本的值，返回true，如果当前k-v不能被插入（bucket满了，并且不是对原有的key进行更新），则：</p>
<ul>
<li>如果局部深度（容量）等于全局深度，增加全局深度，并且对dict的容量翻倍</li>
<li>增加当前要插入的bucket的深度</li>
<li>分裂当前的bucket，对其进行rehash</li>
</ul>
<p>之后再进行重试，在此Lab当中，在插入之前进行容量的检测并进行rehash</p>
</li>
<li>
<p><code>Remove(K)</code>:删除给定的Key，存在则返回true，否则返回false</p>
</li>
<li>
<p><code>GetGlobalDepth()</code>:返回全局深度</p>
</li>
<li>
<p><code>GetNumBuckets()</code>:返回当前存在的bucket的总量</p>
</li>
</ul>
<p><strong>Hint</strong>：</p>
<ul>
<li>可以使用<code>IndexOf(K)</code>​来求出当前Key所属的bucket</li>
<li>Bucket作为一个内嵌类之于HashTable</li>
<li>保证线程安全，使用std::mutex</li>
</ul>
<h3 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h3>
<p>逻辑上较为清晰，首先实现Bucket类，在KV的管理上，需要实现Find、Insert、Remove操作，并且需要有一系列获取相关信息的操作，</p>
<p>Bucket本身是由一个链表进行组织的，实现上直接调用std::list的API即可</p>
<p>主要讨论一下Hash过程</p>
<p>对于可扩展哈希，主要有四个变量：</p>
<ul>
<li>size_dir_：表示整个目录的大小，扩展时进行翻倍</li>
<li>size_bucket_：一个bucket中能够存放的最大的元素，为固定值</li>
<li>global_depth：根据global_depth的位数将key hash到对应的bucket当中</li>
<li>local_depth：在bucket split时使用local_depth进行rehash</li>
</ul>
<p>在引入了深度的概念之后，由于可扩展哈希分为bucket和bucket当中的元素，对应的就有全局深度和本地深度的区分，如果全局深度为2，则证明当前至多只能有4个Bucket，（而实际的bucket数量可能并没有4个，存在多个dir指向同一个bucket的情况）而如果本地深度为2，则下次bucket进行分裂时，使用<code>local_depth +1</code>​位进行rehash(如果认为最右一位为第1位，实际上只需要将1左移local_depth位即可）</p>
<p>在搜索时，先根据<code>global_depth</code>​找到所属的bucket，再在bucket其中遍历寻找到元素</p>
<p>明确了概念之后，可以捋一下整个过程：</p>
<p>尝试向其中插入[0,1,2,3,4,5]</p>
<blockquote>
<p>当bucket满了时：</p>
<ul>
<li>如果局部深度（容量）等于全局深度，增加全局深度，并且对dict的容量翻倍</li>
<li>增加当前要插入的bucket的深度</li>
<li>分裂当前的bucket，对其进行rehash</li>
</ul>
</blockquote>
<ol>
<li>最初在初始化时，<code>global_depth = 0</code>​ <code>local_depth = 0</code>​,此时只有一个bucket，并且当中能够存放一个元素</li>
</ol>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230320161241-0ox7dzl.png" alt=""  />
</p>
<ol start="2">
<li>
<p>之后向其中插入元素1，而此时bucket当中有两个元素，需要对其进行区分，(触发了全局深度等于本地深度的条件)，因此：</p>
<ol>
<li>增加全局深度，<code>global_depth = 1</code>​,bucket数量翻倍</li>
<li>增加本地深度，<code>local_depth = 1</code>​</li>
<li>rehash</li>
</ol>
<p>说一下最后的rehash的过程，虽然此时<code>local_depth = 1</code>​，但是在<code>gloabal_depth=1</code>​的条件下，hash码01无法定位到0号bucket，因此需要对其进行rehash</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230320162131-2t18hps.png" alt=""  />
</p>
</li>
<li>
<p>此时再向其中插入2（10），<code>global_depth = 1</code>​因此会被rehash到0号bucket当中，而0号bucket并未满，因此可以将其插入到其中，3（11）同理，结果如下：</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230320163515-pgfq4be.png" alt=""  />
</p>
</li>
<li>
<p>再向其中插入4(100),在<code>global_depth = 1</code>​的条件下被分配到0号bucket，而此时bucket0已满，按照上面的要求步骤对bucket0再split一次，插入后的结果如下：</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230320165217-0u9178c.png" alt=""  />
</p>
</li>
<li>
<p>插入5和4同理，将bucket1进行split,最终结果如下：</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230320165111-9qft1np.png" alt=""  />
</p>
</li>
</ol>
<p>还有一点需要讨论的是，并不是通过<code>gloal_depth</code>​ + <code>local_depth</code>​对key给进行定位，对于<code>global_depth</code>​，既是代表当前的dir数量，2则代表有00 01 10 11四个bucket，并且对于一个哈希码，确实可以通过<code>global_depth</code>​位就将其归于属于的bucket当中，但是对于<code>local_depth</code>​，仅仅只是在split时用于将当前bucket中的元素和新插入的元素rehash到不同的bucket当中，即与key的搜索无关，也与bucket的容量无关。</p>
<p>对于local_depteh &lt; global_depth的bucket，会存在多个dir指向同一个bucket的情况，当local_depth = global_depth时，则只会有一个dir指向该bucket。</p>
<p>而在bucket split时，通过local_depth来决定元素都属于哪一个新的bucket当中。即将1左移local_depth位，即为local_mask，hash该位为1的归于一个bucket当中,为0的归于一个bucket当中。</p>
<p>之后再去考虑两个新的bucket均需要属于哪个dir，上一步位与为0应当对应原本的dir[i]，而另外一个应当为dir[i+local_mask]。因此现在所做的就是需要找到i为多少，计算hash值然后取local_depth位，再与local_mask位与，结果为0即为low_bucket,为1即为high_bucket。</p>
<p>此外需要考虑连续分裂的问题，如[0 1024 4]进行一次split不足以将这三者区分开，因此一种解决方法是在split最后调用extendiable_hash_table中的Insert，而不是调用bucket的insert，让哈希表的Insert再去判断一遍是否还需要分裂，不过这样嵌套调用无法使用RAII类型的锁，需要手动去加锁解锁。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">template</span> &lt;<span style="color:#fff;font-weight:bold">typename</span> K, <span style="color:#fff;font-weight:bold">typename</span> V&gt;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> ExtendibleHashTable&lt;K, V&gt;::Insert(<span style="color:#fff;font-weight:bold">const</span> K &amp;key, <span style="color:#fff;font-weight:bold">const</span> V &amp;value) {
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">//std::scoped_lock&lt;std::mutex&gt; lock(latch_);
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  latch_.lock();
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> index = IndexOf(key);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> bucket = <span style="color:#fff;font-weight:bold">this</span>-&gt;dir_[index];
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">bool</span> result = bucket-&gt;Insert(key, value);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (result) {
</span></span><span style="display:flex;"><span>    latch_.unlock();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  RedistributeBucket(bucket,key,value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">template</span> &lt;<span style="color:#fff;font-weight:bold">typename</span> K, <span style="color:#fff;font-weight:bold">typename</span> V&gt;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> ExtendibleHashTable&lt;K, V&gt;::RedistributeBucket(std::shared_ptr&lt;Bucket&gt; bucket,<span style="color:#fff;font-weight:bold">const</span> K &amp;key,<span style="color:#fff;font-weight:bold">const</span> V &amp;value) -&gt; <span style="color:#fff;font-weight:bold">void</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (!bucket-&gt;IsFull()) {
</span></span><span style="display:flex;"><span>    latch_.unlock();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (bucket-&gt;GetDepth() == <span style="color:#fff;font-weight:bold">this</span>-&gt;GetGlobalDepthInternal()) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">auto</span> size = dir_.size();
</span></span><span style="display:flex;"><span>    dir_.reserve(size * <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    std::copy_n(dir_.begin(),size,std::back_inserter(dir_));
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">this</span>-&gt;global_depth_++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> last_depth = bucket-&gt;GetDepth();
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> high_bucket = std::make_shared&lt;Bucket&gt;(bucket_size_,last_depth + <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> low_bucket = std::make_shared&lt;Bucket&gt;(bucket_size_,last_depth + <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>  num_buckets_++;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">int</span> local_mask = <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; last_depth;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">auto</span> &amp;[k,v] : bucket-&gt;GetItems()) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (std::hash&lt;K&gt;()(k) &amp; local_mask) {
</span></span><span style="display:flex;"><span>      high_bucket-&gt;Insert(k,v);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      low_bucket-&gt;Insert(k,v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> i = std::hash&lt;K&gt;()(key) &amp; (local_mask - <span style="color:#ff0;font-weight:bold">1</span>);i &lt; dir_.size();i += local_mask) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt; (i &amp; local_mask)) {
</span></span><span style="display:flex;"><span>      dir_[i] = high_bucket;
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      dir_[i] = low_bucket;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">//auto new_index = IndexOf(key);
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  latch_.unlock();
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">this</span>-&gt;Insert(key,value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在实现上先实现Bucket即可，先将Bucket设置为无锁的类型，再整个HashTable上加一把大锁，后续再考虑进行改进，以提高并发度</p>
<h2 id="task2-lru-k">Task2 LRU-K<a hidden class="anchor" aria-hidden="true" href="#task2-lru-k">#</a></h2>
<p>在淘汰时选择<strong>Backward k-distance</strong>最大的进行淘汰，<strong>Backword-distance</strong>使用当前的时间戳和第前K次访问的时间戳进行计算，还未达到K次访问的<strong>Backword-distance</strong>记为正无穷，而当有多个正无穷时，则选择最早的时间戳进行淘汰。</p>
<p><code>LRUKReplacer</code>​和<code>BufferPool</code>​的大小一致，但是任何时刻下并不是所有page都会去考虑被淘汰，</p>
<h3 id="相关函数-1">相关函数<a hidden class="anchor" aria-hidden="true" href="#相关函数-1">#</a></h3>
<ul>
<li><code>Evict(frame_id_t*)</code>:在被Replacer记录的所有的可淘汰的frame中选择<strong>Backward k-distance</strong>最大的那一个，在参数中保存淘汰page的Id，返回true，如果没有可淘汰的frame则返回false</li>
<li><code>RecordAccess(frame_id_t)</code>​：基于当前的时间戳，记录给定的frameid，当一个page被<code>BufferPoolManager</code>​pin时调用</li>
<li><code>Remove(frame_id_t)</code>​：清除一个frame的所有相关历史，当page被删除时调用</li>
<li><code>SetEvictable(frame_id_t,bool set_evictable)</code>​：标记一个frame是否可清理</li>
<li><code>Size()</code>​返回可清除的frame的数量。</li>
</ul>
<h3 id="实现-1">实现<a hidden class="anchor" aria-hidden="true" href="#实现-1">#</a></h3>
<h4 id="相关概念">相关概念<a hidden class="anchor" aria-hidden="true" href="#相关概念">#</a></h4>
<p>LRU-K所针对的为缓存污染的问题，即遇到全表遍历等大量读取多个不重复的page时，如果使用LRU会将当前缓存中的所有的page全部淘汰掉，从而造成缓存失效的问题。</p>
<p>在LRU-K中，主要的淘汰依据为<code>backword k-distance</code>​​，即据K次访问前的距离，</p>
<ul>
<li>而此处的距离作为时间的抽象，访问时间距离当前越久则为时间越长。而前K次访问的距离则是前K次访问的时间，可以用时间戳来表示</li>
<li>而对于访问次数还未到K次的情况，则是将其记为+inf，即正无穷</li>
<li>当进行淘汰时，选择<code>backword k-distance</code>​最大的frame进行淘汰</li>
</ul>
<p>因此，由于还未访问到K次的frame会被记为正无穷，因此淘汰时会选择还未访问到k次的进行淘汰，而如果存在多个访问还不到K次的frame，则该几个frame之间使用普通的LRU进行淘汰，比较上一次的访问时间，其实即为k = 1的情况。</p>
<p>而如果全部为访问了K次以及以上的frame，那么则选择distance最大的进行淘汰。</p>
<p>目前能够想到的方案就是对于frame使用一个map来管理，而对每个frame封装一个frameInfo，在其中维护如是否为+inf，一次一个长度为K的链表，记录前K次的访问时间。但是这样的问题就是每次淘汰frame时需要遍历整个map，统计出K次访问最久远的frame，无法想LRU那样在O(1)的时间复杂度完成get/put。</p>
<p>时间戳可使用自增的id即可。</p>
<p>此外还有一个概念，BufferPool和LRU-K Replacer当中存储的为<code>frame</code>​，在BufferPool当中，应当预先初始化好一定的frame，之后frame的数量一直不变，每个frame对应一个frame_id，任何大于总容量的frame_id均为非法的frame_id。在replacer当中定义一个replacer_size，其大小应当和buffer_pool的size大小相同，同样对违法的frame_id进行检测</p>
<h4 id="实现-2">实现<a hidden class="anchor" aria-hidden="true" href="#实现-2">#</a></h4>
<p><strong>单HashMap内嵌List</strong></p>
<p>说清楚了相关概念，就再说一下如何实现，我主要想到了两种实现方案，第一种是上述的<code>FrameInfo</code>​，然后在一个HashMap当中去管理所有的FrameInfo，定义如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">struct</span> FrameInfo{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">bool</span> isInf{<span style="color:#fff;font-weight:bold">true</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">bool</span> evictable{<span style="color:#fff;font-weight:bold">true</span>};
</span></span><span style="display:flex;"><span>    std::deque&lt;size_t&gt; access_timestamp_;
</span></span><span style="display:flex;"><span>    FrameInfo() = <span style="color:#fff;font-weight:bold">default</span>;
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>isInf</code>​表示当前是否已经被访问了K次，如果还未，则设置为true，之后进行淘汰时优先淘汰还未访问K次的frame，当到达K次之后再设置为false。</p>
</li>
<li>
<p><code>evictable</code>​​表示当前的frame是否能被淘汰，用于在bufferpool当中pin住一些page，同时<code>evictable</code>​​也决定当前replacer的size。</p>
</li>
<li>
<p><code>deque</code>​表示当前的该frame被访问的时间戳，大小上限为K，只保存K次以内的情况（不知道为什么用list就插入不进去，最后选择了deque，c++学太烂了先不管了）</p>
</li>
</ul>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230322231114-gk3tsn9.png" alt=""  />
</p>
<p>在这种实现方式下就不怎么分历史队列和缓冲队列了，反正历史队列和缓冲队列本身都要要存入bufferPool当中的，不如直接统一管理</p>
<p><strong>Record_access</strong>：添加一次访问记录时首先判断之前是否访问过，如果访问过则找到之前的访问记录，则在尾部添加一条新的，注意是否超过K次取消掉+inf和超过K次之后把最早的删除掉即可，如果之前没有相关记录则直接新建一条即可</p>
<p><strong>Remove、Size、SetEvictable</strong>的实现较为简单，按照注释完成即可</p>
<p><strong>Evict</strong>：按照LRU-K原本的定义，应当先遍历历史队列，如果当中有frame的访问历史记录，则从历史队列中删除，历史队列当中如果没有能够可以淘汰的再选择从缓存队列中进行淘汰。因此对整个FrameInfo Map进行遍历，</p>
<p>标记所有的inf，记录最小的时间戳，同时也记录访问了K次的，记录最小的时间戳，最终如果找到过inf的，则选择inf的进行淘汰，否则淘汰访问了K次的，注意跳过<code>non-evictable</code>​即可，弄清楚了LRU-K的概念之后实现起来就没有什么难度了。</p>
<p><strong>双List+单HashMap</strong>​</p>
<p>这种方式则使用将历史记录和缓存分别使用两个List管理，之后删除是先遍历历史记录的List，如果找不到可以删除的，则再遍历缓存的List，</p>
<ul>
<li>在添加一次新的访问时，如果之前毫无记录，则将其添加到历史记录当中，并使用HashMap存储记录当前的迭代器位置和所属的队列，</li>
<li>如果访问次数i <code>1&lt; i &lt; k</code>​,由于比较的是最早的访问时间，因此什么都不用做</li>
<li>如果访问次数到达K次，则将其移入到缓冲队列当中，更新Map当中相关的迭代器和所属队列</li>
<li>如果超过K次，则将其移入到缓冲队列的尾部，淘汰时从头部开始进行淘汰，更新迭代器</li>
</ul>
<p>当淘汰时则先遍历历史队列，寻找第一个<code>evictable</code>​的frame进行淘汰，如果找不到，再去缓冲队列当中去寻找。</p>
<p>严格来说这种实现方法更符合LRU-K原本的定义，这样如果不考虑 <code>evictable</code>​所带来的额外比较，在evict remove时的时间复杂度为O(1)，而之前那种实现方式需要遍历整个Map因此为常数复杂度，等有空考虑重构优化一下。</p>
<p>本身也没有什么线程安全问题，各个函数直接一个区域锁利用 RAII保平安。</p>
<h2 id="task3-buffer-pool-manager-instance">Task3 Buffer Pool Manager Instance<a hidden class="anchor" aria-hidden="true" href="#task3-buffer-pool-manager-instance">#</a></h2>
<p>从磁盘当中去读取page存储到内存当中，当Buffer Pool满了之后，再使用LRU-K将page从内存中淘汰，写回到硬盘上。</p>
<p>内存中的Page使用<code>Page</code>​对象进行抽象，buffer pool无需关心page当中的内容，page当中包含一块内存，对应一个物理页，之后将对应的内存上的内容写入到硬盘上，一个<code>Page</code>​对应一个物理页，通过<code>page_id</code>​进行表述，如果该page没有对应的物理页，则page_id为<code>INVALID_PAGE_ID</code>​</p>
<p>Page当中需要有一个计数器记录有多少个线程<code>pinned</code>​了该page，对于被<code>pinned</code>​的page，不允许将其释放，page需要记录是否为<code>dirty</code>​，如果非<code>dirty</code>​则淘汰时不需要回写硬盘，而<code>dirty</code>​的page需要先回写再重新使用</p>
<p>使用之前的<code>ExtendiableHashTable</code>​进行page_id到frame_id的映射，使用<code>LRUKReplacer</code>​来记录各个page的使用情况</p>
<ul>
<li><code>FetchPgImp(page_id)</code>​：如果没有可用的page并且其他的page全部被<code>pinned</code>​了,返回nullptr</li>
<li><code>UnpinPgImp(page_id, is_dirty)</code>​</li>
<li><code>FlushPgImp(page_id)</code>​：不管是否被pin，都将page给刷盘</li>
<li><code>NewPgImp(page_id)</code>​：<code>AllocatePage</code>​用于生成一个唯一的PageId，<code>DeallocatePage</code>​ 模拟将page刷盘到硬盘上，在DeletePgImp当中调用</li>
<li><code>DeletePgImp(page_id)</code>​</li>
<li><code>FlushAllPagesImpl()</code>​​</li>
</ul>
<h3 id="实现-3">实现<a hidden class="anchor" aria-hidden="true" href="#实现-3">#</a></h3>
<p>Buffer Pool的整体实现并不难，首先描述一下整个Buffer Pool的物理结构，Buffer Pool当中的容器或者说page的载体为frame，所有的frame本身是不变的，即frame的数量即为Buffer Pool的大小，在Buffer Pool进行初始化时，初始化一个Frame数组，其中每一个元素及对应着一个Frame，数组的下表即为Frame_id，如果page为尚未初始化的状态，则代表该frame当中还未存放元素，当有一个Page要受到Buffer Pool管理时，则对该Page进行初始化，设置对应的PageId和元数据 以及Page当中存储的数据设置到该Page当中。</p>
<p>除此之外还有Buffer Pool的管理数据结构，即前两个task所实现的可扩展哈希表和LRU-K Replacer，以及一个用于记录空frame的链表</p>
<p>当一个Page要加入到Buffer Pool当中，无论是新建一个Page还是从硬盘当中读取一个Page，首先先尝试从空frame链表当中获取一个frame_id，之后在Page数组当中对其进行初始化，而如果空闲链表当中没有额外的frame_id去分配，则证明当前的Buffer Pool已满，因此需要尝试通过LRU-K去淘汰一个当前Page的，获取一个新的Page，为了流程的统一，就淘汰之后再将frame加入到空闲链表当中，之后再从空闲链表当中尝试去获取一个Page。将新的Page重新让Replacer和page_table去管理。</p>
<p>以NewPage为例，大致架构如下：</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230324120434-vkkubsq.png" alt=""  />
</p>
<p>搞清楚了整体架构再实现起来就比较方便了，这里就简单解释一下几个函数的相关作用,</p>
<ul>
<li>
<p><strong>NewPage</strong>：即为上层需要创建一个新的Page用于存储新的数据，如在Insert时进行调用，即按照上图的步骤完成即可，先后尝试从<code>free_list_</code>​,若不能则告知<code>replacer</code>​进行淘汰，再从<code>free_list_</code>​当中进行获取，最后创建Page，并Page交给BufferPool管理。</p>
<p>此外，创建Page即代表上层需要一个Page来承载数据，即当前需要使用该Page，因此需要该Page驻留在Buffer Pool当中，因此创建之后应当<code>pin</code>​住它，即修改<code>pin_count_</code>​和<code>evictable</code>​。</p>
<p>由于涉及修改好几个数据结构，因此做了一个封装：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> BufferPoolManagerInstance::CreateNewPage(frame_id_t empty_frame_id) -&gt; Page * {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">auto</span> new_page_id = AllocatePage();
</span></span><span style="display:flex;"><span>  Page *new_page = &amp;pages_[empty_frame_id];
</span></span><span style="display:flex;"><span>  ResetPage(new_page, new_page_id);
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// pin a new page
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  new_page-&gt;pin_count_++;
</span></span><span style="display:flex;"><span>  AddNewPageToBufferPool(empty_frame_id, new_page_id);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> new_page;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> BufferPoolManagerInstance::AddNewPageToBufferPool(frame_id_t frame_id, page_id_t page_id) -&gt; <span style="color:#fff;font-weight:bold">void</span> {
</span></span><span style="display:flex;"><span>  replacer_-&gt;RecordAccess(frame_id);
</span></span><span style="display:flex;"><span>  replacer_-&gt;SetEvictable(frame_id, <span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>  page_table_-&gt;Insert(page_id, frame_id);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<code>replacer_</code>​淘汰一个page封装成一个函数，淘汰之后如果为脏页则需要进行Flush刷盘，因为<code>EvictPage</code>​会被加锁的NewPage调用，因此自身并不加锁，而且调用无锁的<code>FlushPage</code>​</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> BufferPoolManagerInstance::EvictPage() -&gt; <span style="color:#fff;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>  frame_id_t frame_id;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">bool</span> result = replacer_-&gt;Evict(&amp;frame_id);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (!result) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// if frame can be evicted,it means page is not pinned;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  Page *page_to_evict = &amp;pages_[frame_id];
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> (page_to_evict-&gt;IsDirty()) {
</span></span><span style="display:flex;"><span>    FlushWithoutLock(page_to_evict-&gt;GetPageId());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  free_list_.push_back(frame_id);
</span></span><span style="display:flex;"><span>  page_table_-&gt;Remove(page_to_evict-&gt;page_id_);
</span></span><span style="display:flex;"><span>  replacer_-&gt;Remove(frame_id);
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>FetchPage</strong>​：在流程上和<code>NewPage</code>​差不多，尝试从Buffer Pool当中获取一个Page，如果<code>page_table_</code>​当中有则证明存在于Buffer Pool当中 ，直接读取返回。而如果没有则分别从<code>free_list_</code>​和<code>replacer</code>​当中尝试找到一个<code>frame</code>​来承载Page，使用<code>disk_manager_</code>​进行读取，然后交给<code>Buffer Pool</code>​管理。</p>
<p>由于<code>FetchPage</code>​的目的也是去读取一个Page为上层所用，因此同样需要将其pin住，直至使用完。</p>
<p>此外如果是通过<code>free_list_</code>​和<code>replacer_</code>​所获取的Frame需要先清除上一个Page在其中残留的数据，之后加载新数据，由于grade_scope上传时不会去打包<code>Page.h</code>​，因此不应当对<code>Page.h</code>​进行修改，因此将该函数封装到Buffer Pool当中</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> BufferPoolManagerInstance::ResetPage(Page *page, page_id_t page_id) -&gt; <span style="color:#fff;font-weight:bold">void</span> {
</span></span><span style="display:flex;"><span>  page-&gt;ResetMemory();
</span></span><span style="display:flex;"><span>  page-&gt;page_id_ = page_id;
</span></span><span style="display:flex;"><span>  page-&gt;pin_count_ = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>  page-&gt;is_dirty_ = <span style="color:#fff;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>UnpinPage</strong>​：<code>NewPage</code>​和<code>FetchPage</code>​均为获取一个Page，之后为上层所用，因此获取的同时会Pin住该Page，而<code>UnpinPage</code>​即为用于在使用完page之后取消对该page的占用，让其可以被淘汰。</p>
<p><code>Unpin</code>​一次则对<code>pin_count_</code>​递减一次，当为0时证明没有任何上层函数在占用该Page，则可以<code>set evictable</code>​，之后<code>replacer</code>​即可对其进行淘汰</p>
<p>同时<code>UnpinPage</code>​会传入一个<code>is_dirty</code>​，来代表之前占有Page时进行的操作是读操作还是写操作。此外Page上<code>is_diry</code>​的修改会有一定的限制，即如果原本为脏页，那么此次进行的是读操作，那么不能进行修改，需要保持脏页状态。而如果原本非脏页，那么即可随意修改。</p>
</li>
<li>
<p><code>FlushPage</code>​ <code>DeletePage</code>​ <code>FlushAllPage</code>​等逻辑比较简单，按照注释写基本就没什么问题。</p>
</li>
</ul>
<h3 id="debug">debug<a hidden class="anchor" aria-hidden="true" href="#debug">#</a></h3>
<p>关于线程安全，保险的方案就是使用一个区域锁锁住整个函数，一把大锁保平安，但是之前写的时候在<code>EvictPage</code>​当中偷懒复用了一下<code>FlushPage</code>​，因此调用前解锁，调用完再加锁，导致了一个中间状态，再解锁的间隙所就被在并发的其他函数（<code>UnpinPage</code>​）抢走了，如果按照事务的说法就是违反了原子性，导致已经<code>pin_count_ = 0</code>​的Page又被其他的线程抢走了重新<code>Unpin</code>​一次</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230324130451-go4cb37.png" alt=""  />
</p>
<p>因此最终选择单独封装了一个无锁版本的<code>FlushWithoutLock</code>​，之后<code>EvictPage</code>​ <code>FlushPage</code>​ <code>FlushAllPage</code>​全部调用该函数。即可保证线程安全，不会出现中间态。</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>整个Buffer Pool的难度并不算大，写完之后也大致感受到了BusTub和6.830的侧重点 相比于6.830 BusTub少了很多dirty work，更注重于核心部分的实现，像表结构，Catalog，和HeapFile统统没有让我去写，而是专注于整个Buffer Pool。</p>
<p>Buffer Pool 从0开始 可扩展哈希表+LRU-K的实现也有意思很多，相比于6.830的直接无脑一个ConcurrentHashMap，淘汰策略也没有做任何要求，FIFO也能通过测试。</p>
<p>不过个人感觉刚接触数据库的话6.830可能比较友好一点，能对数据库的各方面都有一定的了解，有些dirty work首先一边体会才更深，例如HeapPage HeapFile里面的一个比较Tricky的位于算和Bit map，445的话就不能光去实现project了，其他地方的源码最好也读一读。</p>
<p>‍</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://itfischer.space/en/posts/tech/bustub/bustub-lab2-c1/">
    <span class="title">« Prev</span>
    <br>
    <span>BusTub Lab2 B&#43;Tree Index checkpoint1</span>
  </a>
  <a class="next" href="http://itfischer.space/en/posts/tech/bustub/bustub-lab0/">
    <span class="title">Next »</span>
    <br>
    <span>BusTub Lab0 cpp primer</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on x"
            href="https://x.com/intent/tweet/?text=BusTub%20Lab1%20Buffer%20Pool%20Manager&amp;url=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f&amp;title=BusTub%20Lab1%20Buffer%20Pool%20Manager&amp;summary=BusTub%20Lab1%20Buffer%20Pool%20Manager&amp;source=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f&title=BusTub%20Lab1%20Buffer%20Pool%20Manager">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on whatsapp"
            href="https://api.whatsapp.com/send?text=BusTub%20Lab1%20Buffer%20Pool%20Manager%20-%20http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on telegram"
            href="https://telegram.me/share/url?text=BusTub%20Lab1%20Buffer%20Pool%20Manager&amp;url=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab1 Buffer Pool Manager on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=BusTub%20Lab1%20Buffer%20Pool%20Manager&u=http%3a%2f%2fitfischer.space%2fen%2fposts%2ftech%2fbustub%2fbustub-lab1%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://itfischer.space/en/">Fischer&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
