<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>BusTub Lab3 Query Execution | Fischer&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Lab3 Task1 火山模型 在Task1当中实现了SeqScan​ Insert​ Delete​ IndexScan​，由于均为火山模型，因此在实现上大同小异，">
<meta name="author" content="Fischer">
<link rel="canonical" href="https://fischer0522.github.io/en/posts/tech/bustub/bustub-lab3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://fischer0522.github.io/img/Navigation.svg">
<link rel="icon" type="image/png" sizes="16x16" href="https://fischer0522.github.io/img/Navigation.svg">
<link rel="icon" type="image/png" sizes="32x32" href="https://fischer0522.github.io/img/Navigation.svg">
<link rel="apple-touch-icon" href="https://fischer0522.github.io/Navigation.svg">
<link rel="mask-icon" href="https://fischer0522.github.io/Navigation.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="BusTub Lab3 Query Execution" />
<meta property="og:description" content="Lab3 Task1 火山模型 在Task1当中实现了SeqScan​ Insert​ Delete​ IndexScan​，由于均为火山模型，因此在实现上大同小异，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fischer0522.github.io/en/posts/tech/bustub/bustub-lab3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-15T23:31:34+00:00" />
<meta property="article:modified_time" content="2023-04-18T23:31:33+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BusTub Lab3 Query Execution"/>
<meta name="twitter:description" content="Lab3 Task1 火山模型 在Task1当中实现了SeqScan​ Insert​ Delete​ IndexScan​，由于均为火山模型，因此在实现上大同小异，"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://fischer0522.github.io/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tech",
      "item": "https://fischer0522.github.io/en/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Bustub通关指南",
      "item": "https://fischer0522.github.io/en/posts/tech/bustub/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "BusTub Lab3 Query Execution",
      "item": "https://fischer0522.github.io/en/posts/tech/bustub/bustub-lab3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BusTub Lab3 Query Execution",
  "name": "BusTub Lab3 Query Execution",
  "description": "Lab3 Task1 火山模型 在Task1当中实现了SeqScan​ Insert​ Delete​ IndexScan​，由于均为火山模型，因此在实现上大同小异，",
  "keywords": [
    
  ],
  "articleBody": "Lab3 Task1 火山模型 在Task1当中实现了SeqScan​ Insert​ Delete​ IndexScan​，由于均为火山模型，因此在实现上大同小异，就集中说明一下火山模型，和各自所需要注意的即可。\n火山模型，或者说迭代器模型，核心就是借助迭代器进行遍历。即对于一个算子来说，自身即为一个迭代器，对外提供一个Next方法，将数据处理后通过Next方法一条条给对外提供。以SeqScan为例，每次调用Next都从table当中获取一条tuple，之后交给上层。\n而多个迭代器可以组成迭代器链，上层通过下层的迭代器的Next函数来获取tuple，处理之后又通过自身的迭代器对外返回。就像下图这样，NestedLoopJoin以 MockTableScan作为数据来源，自身处理完的生成的tuple又一条条的通过Next交给Aggregation。\n‍\n此外，这里迭代器采用的是Top-to-Bottom的方式，即以上层的迭代器为驱动，不断的调用下层的Next来获取数据。\nSeqScan：实现一个全表遍历，比较简单，只需要通过table上的迭代器去一条条获取即可\nIndex\u0026Delete：这两个实现上差不多,将子迭代器当中的一条条插入到目标表当中即可。需要注意的是，由于为火山模型，上层会不断的尝试调用Next直至获取到false，因此为了防止重复插入或删除，需要设置一个flag，在完成插入后置为false，之后再调用即可直接返回，中止迭代。\n此外，插入和删除涉及到更新索引，调用一下对应的函数就好\nIndex Scan：SeqScan为通过table的迭代器进行遍历，Index Scan即通过索引来进行遍历，即之前实现的B+树的迭代器，按照Lab知道上给的提示，转换之后获取其迭代器\n1 2 tree_{dynamic_cast\u003cBPlusTreeIndexForOneIntegerColumn *\u003e(index_info_-\u003eindex_.get())}, iter_{tree_-\u003eGetBeginIterator()} 由于BusTub实现的是非聚簇索引，因此索引当中存储的为RID，即一个tuple的唯一标识，RID由page_num 和 slot_num组成，表示该tuple属于哪张表，存在于表的哪个位置。\n之后再去表当中偏移读取获取到所需的tuple\nSQL执行过程 这一部分强烈推荐看一下迟先生写的ButTub养成记。我这里就简单说一下代码当中需要用到的那部分。\n首先，根据SQL解析的结果，优化器会生成一个个的plan_node。代表的一个算子的执行策略，即需要从哪获取数据，获取数据的方式，tuple的结构等等。由于通过抽象语法树一步步的来，整个SQL执行的整体plan同样为树结构组织。\n之后每个算子，被抽象成一个Executor​，代表一个执行的动作。Executor​主要有三部分组成，分别为plan​, executor_context​,child_executor:\nplan即为上述通过优化器的来的具体执行方案，以及所需的数据，如Index_Scan当中会提供index的id，join当中会提供一个用于进行join key的Predicate，以及join的child plan\n根据情况，其会拥有一个或者多个子算子child_executor​ ，即火山模型的迭代器链，通过child_executor​来从底层获取数据。\nexecutor_context​：这个没什么好说的，就是用于保存整个数据库的上下文信息，可以通过其来获取到buffer_pool CataLog LockManager等，相比于6.830将其全部定义在Database类当中作为静态成员变量，个人感觉单独定义一个类作为上下文能够更优雅一点\n1 2 3 4 5 6 7 8 9 Transaction *transaction_; /** The datbase catalog associated with this executor context */ Catalog *catalog_; /** The buffer pool manager associated with this executor context */ BufferPoolManager *bpm_; /** The transaction manager associated with this executor context */ TransactionManager *txn_mgr_; /** The lock manager associated with this executor context */ LockManager *lock_mgr_; Task2 这里设计的有点绕，主要的相关类为：\n​AggregationPlanNode​、SimpleAggregationHashTable​、AggregationExecutor​，一个个来看\nAggregationPlanNode 包含了整个聚合操作的逻辑，通过对SQL的解析而来，包括进行哪些聚合计算，通过什么字段进行group by等。并且由于进行group by支持多个字段，以及一次可能传入多个算子，因此均为数组的形式：\n1 2 3 4 5 6 /** The GROUP BY expressions */ std::vector\u003cAbstractExpressionRef\u003e group_bys_; /** The aggregation expressions */ std::vector\u003cAbstractExpressionRef\u003e aggregates_; /** The aggregation types */ std::vector\u003cAggregationType\u003e agg_types_; 1 2 3 4 query select count(*), min(v1), max(v1), count(v1), sum(v1) from t1; ---- 6 -99999 99999 6 6 以上的一条sql解析完之后就是group_bys为空，arggegates,agg_types分别有5个参数。\n并且，只有参与Aggregation的列才会在生成plan等时候被加入到这几个数组当中，如下sql当中的v4,v5,v4+v5等均不会参与到Aggregation的过程，也不会被添加到数组当中，因此最终v4 v5会存在于group_bys当中，sum、min、count则会存在于aggregates和agg_types当中。\n1 select v4, v5, v4+v5, sum(v1+v2), min(v3+v4), count(*) from t1 group by v4, v5; SimpleAggregationHashTable SimpleAggregationHashTable在内部维护一个std::unordered_map，key为ArrgegateKey，val为一个ArrgegateVal，二者本质上分别为一个vector的简单封装，与6.830不同的是，这里的group by支持多个字段，对于多个字段，可以视为组合成一个联合索引那样。数组大小为算子的数量，存储在这个groupby字段下的所有算子的计算结果。定义分别如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct AggregateKey { /** The group-by values */ std::vector\u003cValue\u003e group_bys_; /** * Compares two aggregate keys for equality. * @param other the other aggregate key to be compared with * @return `true` if both aggregate keys have equivalent group-by expressions, `false` otherwise */ auto operator==(const AggregateKey \u0026other) const -\u003e bool { for (uint32_t i = 0; i \u003c other.group_bys_.size(); i++) { if (group_bys_[i].CompareEquals(other.group_bys_[i]) != CmpBool::CmpTrue) { return false; } } return true; } }; /** AggregateValue represents a value for each of the running aggregates */ struct AggregateValue { /** The aggregate values */ std::vector\u003cValue\u003e aggregates_; }; 1 2 3 4 5 std::unordered_map\u003cAggregateKey, AggregateValue\u003e ht_{}; /** The aggregate expressions that we have */ const std::vector\u003cAbstractExpressionRef\u003e \u0026agg_exprs_; /** The types of aggregations that we have */ const std::vector\u003cAggregationType\u003e \u0026agg_types_; 插入​\n通过查询表得到的最终结果为一个Tuple，而HashTable当中为AggregateKey,AggregateVal，因此需要将tuple进行转换，\nkey为groupby的字段，如果不需要groupby，那么就使用一个空的数组作为key，之后所有的val都会在这个唯一的key上计算。否则则根据提供的group by字段去tuple当中进行提取，生成一个key。\n而对于Value则根据算子所需进行获取即可，如上面的那条Sql，最终vals数组当中所存储的为：[1,val(tuple1),val(tuple1),1(or null),val(tuple1)]​\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 auto MakeAggregateKey(const Tuple *tuple) -\u003e AggregateKey { std::vector\u003cValue\u003e keys; for (const auto \u0026expr : plan_-\u003eGetGroupBys()) { keys.emplace_back(expr-\u003eEvaluate(tuple, child_-\u003eGetOutputSchema())); } return {keys}; } /** @return The tuple as an AggregateValue */ auto MakeAggregateValue(const Tuple *tuple) -\u003e AggregateValue { std::vector\u003cValue\u003e vals; for (const auto \u0026expr : plan_-\u003eGetAggregates()) { vals.emplace_back(expr-\u003eEvaluate(tuple, child_-\u003eGetOutputSchema())); } return {vals}; } 在生成了对应的key，val之后，通过InsertCombine以及CombineAggregateVlues进行插入。在其中找到对应的groupby字段之后，将所有的算子在原本的基础上进行计算。\n1 2 3 4 5 6 void InsertCombine(const AggregateKey \u0026agg_key, const AggregateValue \u0026agg_val) { if (ht_.count(agg_key) == 0) { ht_.insert({agg_key, GenerateInitialAggregateValue()}); } CombineAggregateValues(\u0026ht_[agg_key], agg_val); } Iterator：为了将计算结果进行导出成Tuple，ht还提供了一个迭代器，可以用其对key和val分别进行迭代\nAggregateExecutor 在大致结构上和其他算子基本相同，都有一个由sql解析出来的plan，和一个用于读取数据的child_iterator，此外还有用于存储聚合结果的hashtable和用于导出聚合结果的迭代器.\n1 2 3 4 5 6 7 const AggregationPlanNode *plan_; /** The child executor that produces tuples over which the aggregation is computed */ std::unique_ptr\u003cAbstractExecutor\u003e child_; /** Simple aggregation hash table */ SimpleAggregationHashTable aht_; /** Simple aggregation hash table iterator */ SimpleAggregationHashTable::Iterator aht_iterator_; 与其他的算子不同的是，Aggregation是 pipeline breaker，即其他的火山模型的算子，通过next来获取到一条数据之后，立即向上返回，即自始至终该算子只会拥有或者处理一条tuple，而Aggregation不同的是，他通过child_terator的next获取到所有的数据，当计算完成之后，在通过自身的Next去将结果一条条的向上返回，但是这里依旧是火山模型，只是做了一次截断，并不会像物化模型那样一次性的返回多个tuple。\n因此就需要在Init当中迭代完child_iterator当中的所有的tuple，计算完成之后再通过Next将结果一条条向上返回。\nNext​\n正如上面所说，Next的作用就是通过迭代器，迭代上述存储聚合结果的hashtable，根据数据来一条条生成tuple。分别对key val进行迭代，即groupby和 aggregates，将其作为tuple的一列，插入到一个数组当中，之后根据该数组来构建tuple。\nNestedLoopJoin 这里实现上和6.830的差不多，主要有三个问题：\nduplicated key 需要注意的是不要漏匹配即可,如下表：如果直接双层while嵌套的话，在完成了T1的1 和T2的第一个1匹配完成并返回之后，上层再调用Next，就会调用T1.Next，就会令T1迭代到2，导致T1和T2的第二1匹配遗失，换句话说就是无法处理重复的key\nt1 join t2 on t1.colA = t2.colA​\nT1.colA T2.colA 0 0 1 1 2 1 因此为了防止每次调用Join的Next左表都会向下遍历一次，采用一个变量去暂存一下左表当前的tuple，之后当右表完全遍历完一次之后，左表才会通过Next移动至下一条tuple。\n大致结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 while (true) { if (!has_left_next_) { return false; } for (uint32_t flag = right_idx_ \u003c 0 ? 0 : right_idx_; flag \u003c right_tuple_vec_.size(); flag++) { // scan right tuple return true; } if (right_idx_ == -1 \u0026\u0026 plan_-\u003eGetJoinType() == JoinType::LEFT) { // generate a tuple with null to handle left join has_left_next_ = left_executor_-\u003eNext(\u0026last_left_tuple_, \u0026left_rid); return true; } right_idx_ = -1; has_left_next_ = left_executor_-\u003eNext(\u0026last_left_tuple_, \u0026left_rid); } 右迭代器 在NestedLoopJoin当中，左表当中的每一条数据都会遍历右表来寻找能够匹配的tuple，因此会导致右表的迭代器不断耗尽。最偷懒的方式为当右表的while迭代完成一次之后就调用其Init()​进行重置，不过这样后续又会去磁盘当中读取，造成不必要的io，因此更好的方式为通过一个数组进行暂存，之后遍历这个缓存下来的数组即可，可以减少多次IO。\nleft join BusTub分别支持Inner Join和Left Join，如果左表的一个tuple在右表当中完全没有匹配的话，通过在右表的位置填充null，生成一条数据。\nNestedIndexJoin 和NestedLoopJoin稍有不同，主要是数据的来源，由于驱动表一定要遍历，因此选择没有索引的表作为驱动表，右表的数据获取方式通过索引来实现。由于BusTub的索引不支持重复的key，因此也不需要一个变量来保存左表的tuple防止返回迭代了。如果通过索引能找到，那么就创建一条完整的记录，如果索引当中找不到并且当前的类型为left join，那么就创建一条记录，用null对右值进行填充。大致结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 while (child_executor_-\u003eNext(\u0026left_tuple, \u0026useless_rid)) { std::vector\u003cRID\u003e index_rid; Value value = plan_-\u003eKeyPredicate()-\u003eEvaluate(\u0026left_tuple, child_executor_-\u003eGetOutputSchema()); tree_-\u003eScanKey(Tuple{{value}, index_info_-\u003eindex_-\u003eGetKeySchema()}, \u0026index_rid, exec_ctx_-\u003eGetTransaction()); if (!index_rid.empty()) { // found by the index // generate a tuple return true; } // can not find by index,handle the left join case if (index_rid.empty() \u0026\u0026 plan_-\u003eGetJoinType() == JoinType::LEFT) { // generate tuple with null return true; } } HashJoin 在Lab当中并没有要求实现HashJoin，但是个人感觉比较有意思，再加上单纯在内存当中的HashJoin实现起来并不困难，就给实现了一下\n通过一个HashTable来存储右表当中的tuple，而由于join key可能重复，因此HashTable应当以hash为key，数组为value，数组当中存储有相同join key的Tuple。\n1 2 3 4 5 6 const HashJoinPlanNode *plan_; std::unordered_map\u003chash_t, std::vector\u003cTuple\u003e\u003e join_hash_; std::unique_ptr\u003cAbstractExecutor\u003e left_executor_; std::unique_ptr\u003cAbstractExecutor\u003e right_executor_; std::vector\u003cTuple\u003e result_tuple_; std::vector\u003cTuple\u003e::const_iterator tuple_iter_; 实现上的大致思路就是首先遍历右表，将tuple存储到HashTable当中。之后再遍历左表，去和右表进行匹配，此时相当于在右表上建立了一个HashIndex，如果匹配成功则将其记录到result_tuple数组当中，如果匹配失败，则去考虑是否为LeftJoin，如果是则添加一条右表为空的记录，先遍历右表的原因也是用于处理LeftJoin\n在进行匹配时，需要处理哈希冲突的问题，第一次忘考虑了，出现了9和8300被哈希到了同一个槽当中，之后误匹配上了，解决办法也比较简单，在通过哈希值找到对应的key之后在join前判断一次是否相等即可。\n1 if (right_join_key.CompareEquals(join_key) == CmpBool::CmpTrue) 之后在Next当中通过迭代器去访问result_tuple即可\n使用HashJoin进行优化之后，Leaderboard bonus的Q1执行会快上很多，如果不进行优化的话为30000，使用HashJoin可以到80多\nTask3 分别实现sort​ limit​ topN​三个算子以及topn对应的优化，前两个没什么好说，SeqScan修修补补即可。\nTop-N Top-N主要针对的为sort+limit的情况，即order by xxx limit n​，这种情况如果不进行优化则需要全表遍历并排序，之后再对排序完的结果进行一次计数截取。\n通过Top-N即可保证只有一次全表遍历，计算完之后逐条返回。\n根据lab的提示，很容易就可以确立思路，维护一个优先队列，并且保证当中只有K个数据，即通过Next不断获取并插入到其中，如果达到了K个就弹出一个，保证至多有K个\nThink of what data structure can be used to track the top n elements (Andy mentioned it in the lecture). The struct should hold at most k​ elements (where k​ is the number specified in LIMIT​ clause).\n不过由于std::priority_queue​当中并没有提供迭代器，也没有提供下标访问，而top访问的是排序最低的那个，因此可以使用一个栈，将整个逻辑进行翻转，从而保证从高向低的进行获取。\nTop-N Optimizer 1 2 3 4 5 6 7 8 9 10 11 auto Optimizer::Optimize(const AbstractPlanNodeRef \u0026plan) -\u003e AbstractPlanNodeRef { if (force_starter_rule_) { // Use starter rules when `force_starter_rule_` is set to true. auto p = plan; p = OptimizeMergeProjection(p); p = OptimizeMergeFilterNLJ(p); p = OptimizeNLJAsIndexJoin(p); p = OptimizeOrderByAsIndexScan(p); p = OptimizeSortLimitAsTopN(p); return p; } 将原本未经优化的plan树通过多条规则链式的进行优化，最后得到一个最终的优化结果。对于单个的优化方案，都是采用后续遍历的方式，自底向上的改写plan，将符合的类型进行优化。\n因此照猫画虎的实现一个，通过Top-N对sort+limit的情况进行优化，只有上层为limit，下层为sort的情况，才将其优化为Top-N。\nSummary 总的来说Lab3的难度并不大，并且在本地提供了全部的测试用例，而且不涉及并发，因此可以安心的单步调试，写起来也就比较的粗放一点，面向bug编程。\n整个Lab3做下来给我的感觉是相比于6.830，bustub更注重于深度，在很多地方都提供提供了一定的封装，如磁盘的读写，tuple的读取和写入。虽然少了自行构造table和tuple的过程，对于schema的理解可能差一点，但是在有限的时间内更注重于深度。此外，由于SQL执行这一部分设置在了索引之后，因此在功能的实现上也可以应用索引，如NestedIndexJoin、IndexScan等。在做6.830的基础之上写busTub的话个人感觉会更有收获一点，但是如果只写一个的话，BusTub可能更合适一点，不过需要去阅读一下其他部分的源码，或者像某些佬那样直接自己实现一个BusTub。\n最近手头事有点多，也快考试了，整个文章写的比较仓促，Leaderborad bonus暂时也没时间写了，只能先搁置在一边了。\n",
  "wordCount" : "5872",
  "inLanguage": "en",
  "datePublished": "2023-04-15T23:31:34Z",
  "dateModified": "2023-04-18T23:31:33Z",
  "author":{
    "@type": "Person",
    "name": "Fischer"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fischer0522.github.io/en/posts/tech/bustub/bustub-lab3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Fischer's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fischer0522.github.io/img/Navigation.svg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fischer0522.github.io/en/" accesskey="h" title="Fischer&#39;s Blog (Alt + H)">
                <img src="https://fischer0522.github.io/img/Navigation.svg" alt="" aria-label="logo"
                    height="35">Fischer&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fischer0522.github.io/en/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://fischer0522.github.io/en/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://fischer0522.github.io/en/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://fischer0522.github.io/en/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://fischer0522.github.io/en/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fischer0522.github.io/en/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://fischer0522.github.io/en/">Home</a>&nbsp;»&nbsp;<a href="https://fischer0522.github.io/en/posts/">Blog</a>&nbsp;»&nbsp;<a href="https://fischer0522.github.io/en/posts/tech/">Tech</a>&nbsp;»&nbsp;<a href="https://fischer0522.github.io/en/posts/tech/bustub/">Bustub通关指南</a></div>
    <h1 class="post-title entry-hint-parent">
      BusTub Lab3 Query Execution
    </h1>
    <div class="post-meta"><span title='2023-04-15 23:31:34 +0000 UTC'>2023-04-15</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Fischer

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#lab3" aria-label="Lab3">Lab3</a><ul>
                        
                <li>
                    <a href="#task1" aria-label="Task1">Task1</a><ul>
                        
                <li>
                    <a href="#%e7%81%ab%e5%b1%b1%e6%a8%a1%e5%9e%8b" aria-label="火山模型">火山模型</a></li>
                <li>
                    <a href="#sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" aria-label="SQL执行过程">SQL执行过程</a></li></ul>
                </li>
                <li>
                    <a href="#task2" aria-label="Task2">Task2</a><ul>
                        
                <li>
                    <a href="#aggregationplannode" aria-label="AggregationPlanNode">AggregationPlanNode</a></li>
                <li>
                    <a href="#simpleaggregationhashtable" aria-label="SimpleAggregationHashTable">SimpleAggregationHashTable</a></li>
                <li>
                    <a href="#aggregateexecutor" aria-label="AggregateExecutor">AggregateExecutor</a></li>
                <li>
                    <a href="#nestedloopjoin" aria-label="NestedLoopJoin">NestedLoopJoin</a><ul>
                        
                <li>
                    <a href="#duplicated-key" aria-label="duplicated key">duplicated key</a></li>
                <li>
                    <a href="#%e5%8f%b3%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="右迭代器">右迭代器</a></li>
                <li>
                    <a href="#left-join" aria-label="left join">left join</a></li></ul>
                </li>
                <li>
                    <a href="#nestedindexjoin" aria-label="NestedIndexJoin">NestedIndexJoin</a></li>
                <li>
                    <a href="#hashjoin" aria-label="HashJoin">HashJoin</a></li></ul>
                </li>
                <li>
                    <a href="#task3" aria-label="Task3">Task3</a><ul>
                        
                <li>
                    <a href="#top-n" aria-label="Top-N">Top-N</a></li>
                <li>
                    <a href="#top-n-optimizer" aria-label="Top-N Optimizer">Top-N Optimizer</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="lab3">Lab3<a hidden class="anchor" aria-hidden="true" href="#lab3">#</a></h1>
<h2 id="task1">Task1<a hidden class="anchor" aria-hidden="true" href="#task1">#</a></h2>
<h3 id="火山模型">火山模型<a hidden class="anchor" aria-hidden="true" href="#火山模型">#</a></h3>
<p>在Task1当中实现了<code>SeqScan</code>​ <code>Insert</code>​ <code>Delete</code>​ <code>IndexScan</code>​，由于均为火山模型，因此在实现上大同小异，就集中说明一下火山模型，和各自所需要注意的即可。</p>
<p>火山模型，或者说迭代器模型，核心就是借助迭代器进行遍历。即对于一个算子来说，自身即为一个迭代器，对外提供一个Next方法，将数据处理后通过Next方法一条条给对外提供。以SeqScan为例，每次调用Next都从table当中获取一条tuple，之后交给上层。</p>
<p>而多个迭代器可以组成迭代器链，上层通过下层的迭代器的Next函数来获取tuple，处理之后又通过自身的迭代器对外返回。就像下图这样，NestedLoopJoin以 MockTableScan作为数据来源，自身处理完的生成的tuple又一条条的通过Next交给Aggregation。</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/image-20230418201944-b21rdsg.png" alt=""  />
</p>
<p>‍</p>
<p>此外，这里迭代器采用的是Top-to-Bottom的方式，即以上层的迭代器为驱动，不断的调用下层的Next来获取数据。</p>
<p><strong>SeqScan</strong>：实现一个全表遍历，比较简单，只需要通过table上的迭代器去一条条获取即可</p>
<p><strong>Index&amp;Delete</strong>：这两个实现上差不多,将子迭代器当中的一条条插入到目标表当中即可。需要注意的是，由于为火山模型，上层会不断的尝试调用Next直至获取到false，因此为了防止重复插入或删除，需要设置一个flag，在完成插入后置为false，之后再调用即可直接返回，中止迭代。</p>
<p>此外，插入和删除涉及到更新索引，调用一下对应的函数就好</p>
<p><strong>Index Scan</strong>：SeqScan为通过table的迭代器进行遍历，Index Scan即通过索引来进行遍历，即之前实现的B+树的迭代器，按照Lab知道上给的提示，转换之后获取其迭代器</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>      tree_{<span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>BPlusTreeIndexForOneIntegerColumn <span style="color:#f92672">*&gt;</span>(index_info_<span style="color:#f92672">-&gt;</span>index_.get())},
</span></span><span style="display:flex;"><span>      iter_{tree_<span style="color:#f92672">-&gt;</span>GetBeginIterator()} 
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于BusTub实现的是非聚簇索引，因此索引当中存储的为RID，即一个tuple的唯一标识，RID由page_num 和 slot_num组成，表示该tuple属于哪张表，存在于表的哪个位置。</p>
<p>之后再去表当中偏移读取获取到所需的tuple</p>
<h3 id="sql执行过程">SQL执行过程<a hidden class="anchor" aria-hidden="true" href="#sql执行过程">#</a></h3>
<p>这一部分强烈推荐看一下迟先生写的ButTub养成记。我这里就简单说一下代码当中需要用到的那部分。</p>
<p>首先，根据SQL解析的结果，优化器会生成一个个的plan_node。代表的一个算子的执行策略，即需要从哪获取数据，获取数据的方式，tuple的结构等等。由于通过抽象语法树一步步的来，整个SQL执行的整体plan同样为树结构组织。</p>
<p>之后每个算子，被抽象成一个<code>Executor</code>​，代表一个执行的动作。<code>Executor</code>​主要有三部分组成，分别为<code>plan</code>​, <code>executor_context</code>​,<code>child_executor</code>:</p>
<ul>
<li>
<p>plan即为上述通过优化器的来的具体执行方案，以及所需的数据，如Index_Scan当中会提供index的id，join当中会提供一个用于进行join key的Predicate，以及join的child plan</p>
</li>
<li>
<p>根据情况，其会拥有一个或者多个子算子<code>child_executor</code>​ ，即火山模型的迭代器链，通过<code>child_executor</code>​来从底层获取数据。</p>
</li>
<li>
<p><code>executor_context</code>​：这个没什么好说的，就是用于保存整个数据库的上下文信息，可以通过其来获取到buffer_pool CataLog LockManager等，相比于6.830将其全部定义在Database类当中作为静态成员变量，个人感觉单独定义一个类作为上下文能够更优雅一点</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  Transaction <span style="color:#f92672">*</span>transaction_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The datbase catalog associated with this executor context */</span>
</span></span><span style="display:flex;"><span>  Catalog <span style="color:#f92672">*</span>catalog_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The buffer pool manager associated with this executor context */</span>
</span></span><span style="display:flex;"><span>  BufferPoolManager <span style="color:#f92672">*</span>bpm_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The transaction manager associated with this executor context */</span>
</span></span><span style="display:flex;"><span>  TransactionManager <span style="color:#f92672">*</span>txn_mgr_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The lock manager associated with this executor context */</span>
</span></span><span style="display:flex;"><span>  LockManager <span style="color:#f92672">*</span>lock_mgr_;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="task2">Task2<a hidden class="anchor" aria-hidden="true" href="#task2">#</a></h2>
<p>这里设计的有点绕，主要的相关类为：<br>
​<code>AggregationPlanNode</code>​、<code>SimpleAggregationHashTable</code>​、<code>AggregationExecutor</code>​，一个个来看</p>
<h3 id="aggregationplannode">AggregationPlanNode<a hidden class="anchor" aria-hidden="true" href="#aggregationplannode">#</a></h3>
<p>包含了整个聚合操作的逻辑，通过对SQL的解析而来，包括进行哪些聚合计算，通过什么字段进行group by等。并且由于进行group by支持多个字段，以及一次可能传入多个算子，因此均为数组的形式：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">/** The GROUP BY expressions */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AbstractExpressionRef<span style="color:#f92672">&gt;</span> group_bys_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The aggregation expressions */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AbstractExpressionRef<span style="color:#f92672">&gt;</span> aggregates_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The aggregation types */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AggregationType<span style="color:#f92672">&gt;</span> agg_types_;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>query
</span></span><span style="display:flex;"><span>select <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>), min(v1), max(v1), count(v1), sum(v1) from t1;
</span></span><span style="display:flex;"><span><span style="color:#f92672">----</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">99999</span> <span style="color:#ae81ff">99999</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上的一条sql解析完之后就是group_bys为空，arggegates,agg_types分别有5个参数。</p>
<p>并且，只有参与Aggregation的列才会在生成plan等时候被加入到这几个数组当中，如下sql当中的v4,v5,v4+v5等均不会参与到Aggregation的过程，也不会被添加到数组当中，因此最终v4 v5会存在于group_bys当中，sum、min、count则会存在于aggregates和agg_types当中。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>select v4, v5, v4<span style="color:#f92672">+</span>v5, sum(v1<span style="color:#f92672">+</span>v2), min(v3<span style="color:#f92672">+</span>v4), count(<span style="color:#f92672">*</span>) from t1 group by v4, v5;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="simpleaggregationhashtable">SimpleAggregationHashTable<a hidden class="anchor" aria-hidden="true" href="#simpleaggregationhashtable">#</a></h3>
<p>SimpleAggregationHashTable在内部维护一个std::unordered_map，key为ArrgegateKey，val为一个ArrgegateVal，二者本质上分别为一个vector的简单封装，与6.830不同的是，这里的group by支持多个字段，对于多个字段，可以视为组合成一个联合索引那样。数组大小为算子的数量，存储在这个groupby字段下的所有算子的计算结果。定义分别如下:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AggregateKey</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The group-by values */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span> group_bys_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Compares two aggregate keys for equality.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * @param other the other aggregate key to be compared with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * @return `true` if both aggregate keys have equivalent group-by expressions, `false` otherwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> AggregateKey <span style="color:#f92672">&amp;</span>other) <span style="color:#66d9ef">const</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> other.group_bys_.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (group_bys_[i].CompareEquals(other.group_bys_[i]) <span style="color:#f92672">!=</span> CmpBool<span style="color:#f92672">::</span>CmpTrue) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** AggregateValue represents a value for each of the running aggregates */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AggregateValue</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The aggregate values */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span> aggregates_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>AggregateKey, AggregateValue<span style="color:#f92672">&gt;</span> ht_{};
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The aggregate expressions that we have */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AbstractExpressionRef<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>agg_exprs_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The types of aggregations that we have */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>AggregationType<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>agg_types_;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>插入</strong>​</p>
<p>通过查询表得到的最终结果为一个Tuple，而HashTable当中为AggregateKey,AggregateVal，因此需要将tuple进行转换，</p>
<p>key为groupby的字段，如果不需要groupby，那么就使用一个空的数组作为key，之后所有的val都会在这个唯一的key上计算。否则则根据提供的group by字段去tuple当中进行提取，生成一个key。</p>
<p>而对于Value则根据算子所需进行获取即可，如上面的那条Sql，最终vals数组当中所存储的为：<code>[1,val(tuple1),val(tuple1),1(or null),val(tuple1)]</code>​</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">MakeAggregateKey</span>(<span style="color:#66d9ef">const</span> Tuple <span style="color:#f92672">*</span>tuple) <span style="color:#f92672">-&gt;</span> AggregateKey {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span> keys;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>expr : plan_<span style="color:#f92672">-&gt;</span>GetGroupBys()) {
</span></span><span style="display:flex;"><span>      keys.emplace_back(expr<span style="color:#f92672">-&gt;</span>Evaluate(tuple, child_<span style="color:#f92672">-&gt;</span>GetOutputSchema()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {keys};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** @return The tuple as an AggregateValue */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">MakeAggregateValue</span>(<span style="color:#66d9ef">const</span> Tuple <span style="color:#f92672">*</span>tuple) <span style="color:#f92672">-&gt;</span> AggregateValue {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">&gt;</span> vals;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>expr : plan_<span style="color:#f92672">-&gt;</span>GetAggregates()) {
</span></span><span style="display:flex;"><span>      vals.emplace_back(expr<span style="color:#f92672">-&gt;</span>Evaluate(tuple, child_<span style="color:#f92672">-&gt;</span>GetOutputSchema()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {vals};
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>在生成了对应的key，val之后，通过InsertCombine以及CombineAggregateVlues进行插入。在其中找到对应的groupby字段之后，将所有的算子在原本的基础上进行计算。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertCombine</span>(<span style="color:#66d9ef">const</span> AggregateKey <span style="color:#f92672">&amp;</span>agg_key, <span style="color:#66d9ef">const</span> AggregateValue <span style="color:#f92672">&amp;</span>agg_val) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ht_.count(agg_key) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      ht_.insert({agg_key, GenerateInitialAggregateValue()});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    CombineAggregateValues(<span style="color:#f92672">&amp;</span>ht_[agg_key], agg_val);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Iterator</strong>：为了将计算结果进行导出成Tuple，ht还提供了一个迭代器，可以用其对key和val分别进行迭代</p>
<h3 id="aggregateexecutor">AggregateExecutor<a hidden class="anchor" aria-hidden="true" href="#aggregateexecutor">#</a></h3>
<p>在大致结构上和其他算子基本相同，都有一个由sql解析出来的plan，和一个用于读取数据的child_iterator，此外还有用于存储聚合结果的hashtable和用于导出聚合结果的迭代器.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> AggregationPlanNode <span style="color:#f92672">*</span>plan_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** The child executor that produces tuples over which the aggregation is computed */</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>AbstractExecutor<span style="color:#f92672">&gt;</span> child_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** Simple aggregation hash table */</span>
</span></span><span style="display:flex;"><span>  SimpleAggregationHashTable aht_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/** Simple aggregation hash table iterator */</span>
</span></span><span style="display:flex;"><span>  SimpleAggregationHashTable<span style="color:#f92672">::</span>Iterator aht_iterator_;
</span></span></code></pre></td></tr></table>
</div>
</div><p>与其他的算子不同的是，Aggregation是 pipeline breaker，即其他的火山模型的算子，通过next来获取到一条数据之后，立即向上返回，即自始至终该算子只会拥有或者处理一条tuple，而Aggregation不同的是，他通过child_terator的next获取到所有的数据，当计算完成之后，在通过自身的Next去将结果一条条的向上返回，但是这里依旧是火山模型，只是做了一次截断，并不会像物化模型那样一次性的返回多个tuple。</p>
<p>因此就需要在Init当中迭代完child_iterator当中的所有的tuple，计算完成之后再通过Next将结果一条条向上返回。</p>
<p><strong>Next</strong>​</p>
<p>正如上面所说，Next的作用就是通过迭代器，迭代上述存储聚合结果的hashtable，根据数据来一条条生成tuple。分别对key val进行迭代，即groupby和 aggregates，将其作为tuple的一列，插入到一个数组当中，之后根据该数组来构建tuple。</p>
<h3 id="nestedloopjoin">NestedLoopJoin<a hidden class="anchor" aria-hidden="true" href="#nestedloopjoin">#</a></h3>
<p>这里实现上和6.830的差不多，主要有三个问题：</p>
<h4 id="duplicated-key">duplicated key<a hidden class="anchor" aria-hidden="true" href="#duplicated-key">#</a></h4>
<p>需要注意的是不要漏匹配即可,如下表：如果直接双层while嵌套的话，在完成了T1的1 和T2的第一个1匹配完成并返回之后，上层再调用Next，就会调用T1.Next，就会令T1迭代到2，导致T1和T2的第二1匹配遗失，换句话说就是无法处理重复的key</p>
<p><code>t1 join t2 on t1.colA = t2.colA</code>​</p>
<table>
<thead>
<tr>
<th>T1.colA</th>
<th></th>
<th>T2.colA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>因此为了防止每次调用Join的Next左表都会向下遍历一次，采用一个变量去暂存一下左表当前的tuple，之后当右表完全遍历完一次之后，左表才会通过Next移动至下一条tuple。</p>
<p>大致结构如下：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>has_left_next_) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> flag <span style="color:#f92672">=</span> right_idx_ <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> right_idx_; flag <span style="color:#f92672">&lt;</span> right_tuple_vec_.size(); flag<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// scan right tuple
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (right_idx_ <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> plan_<span style="color:#f92672">-&gt;</span>GetJoinType() <span style="color:#f92672">==</span> JoinType<span style="color:#f92672">::</span>LEFT) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// generate a tuple with null to handle left join
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	has_left_next_ <span style="color:#f92672">=</span> left_executor_<span style="color:#f92672">-&gt;</span>Next(<span style="color:#f92672">&amp;</span>last_left_tuple_, <span style="color:#f92672">&amp;</span>left_rid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    right_idx_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    has_left_next_ <span style="color:#f92672">=</span> left_executor_<span style="color:#f92672">-&gt;</span>Next(<span style="color:#f92672">&amp;</span>last_left_tuple_, <span style="color:#f92672">&amp;</span>left_rid);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="右迭代器">右迭代器<a hidden class="anchor" aria-hidden="true" href="#右迭代器">#</a></h4>
<p>在NestedLoopJoin当中，左表当中的每一条数据都会遍历右表来寻找能够匹配的tuple，因此会导致右表的迭代器不断耗尽。最偷懒的方式为当右表的while迭代完成一次之后就调用其<code>Init()</code>​进行重置，不过这样后续又会去磁盘当中读取，造成不必要的io，因此更好的方式为通过一个数组进行暂存，之后遍历这个缓存下来的数组即可，可以减少多次IO。</p>
<h4 id="left-join">left join<a hidden class="anchor" aria-hidden="true" href="#left-join">#</a></h4>
<p>BusTub分别支持Inner Join和Left Join，如果左表的一个tuple在右表当中完全没有匹配的话，通过在右表的位置填充null，生成一条数据。</p>
<h3 id="nestedindexjoin">NestedIndexJoin<a hidden class="anchor" aria-hidden="true" href="#nestedindexjoin">#</a></h3>
<p>和NestedLoopJoin稍有不同，主要是数据的来源，由于驱动表一定要遍历，因此选择没有索引的表作为驱动表，右表的数据获取方式通过索引来实现。由于BusTub的索引不支持重复的key，因此也不需要一个变量来保存左表的tuple防止返回迭代了。如果通过索引能找到，那么就创建一条完整的记录，如果索引当中找不到并且当前的类型为left join，那么就创建一条记录，用null对右值进行填充。大致结构如下：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (child_executor_<span style="color:#f92672">-&gt;</span>Next(<span style="color:#f92672">&amp;</span>left_tuple, <span style="color:#f92672">&amp;</span>useless_rid)) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>RID<span style="color:#f92672">&gt;</span> index_rid;
</span></span><span style="display:flex;"><span>    Value value <span style="color:#f92672">=</span> plan_<span style="color:#f92672">-&gt;</span>KeyPredicate()<span style="color:#f92672">-&gt;</span>Evaluate(<span style="color:#f92672">&amp;</span>left_tuple, child_executor_<span style="color:#f92672">-&gt;</span>GetOutputSchema());
</span></span><span style="display:flex;"><span>    tree_<span style="color:#f92672">-&gt;</span>ScanKey(Tuple{{value}, index_info_<span style="color:#f92672">-&gt;</span>index_<span style="color:#f92672">-&gt;</span>GetKeySchema()}, <span style="color:#f92672">&amp;</span>index_rid, exec_ctx_<span style="color:#f92672">-&gt;</span>GetTransaction());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>index_rid.empty()) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// found by the index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// generate a tuple
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// can not find by index,handle the left join case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (index_rid.empty() <span style="color:#f92672">&amp;&amp;</span> plan_<span style="color:#f92672">-&gt;</span>GetJoinType() <span style="color:#f92672">==</span> JoinType<span style="color:#f92672">::</span>LEFT) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// generate tuple with null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="hashjoin">HashJoin<a hidden class="anchor" aria-hidden="true" href="#hashjoin">#</a></h3>
<p>在Lab当中并没有要求实现HashJoin，但是个人感觉比较有意思，再加上单纯在内存当中的HashJoin实现起来并不困难，就给实现了一下</p>
<p>通过一个HashTable来存储右表当中的tuple，而由于join key可能重复，因此HashTable应当以hash为key，数组为value，数组当中存储有相同join key的Tuple。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> HashJoinPlanNode <span style="color:#f92672">*</span>plan_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>hash_t, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span> join_hash_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>AbstractExecutor<span style="color:#f92672">&gt;</span> left_executor_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>AbstractExecutor<span style="color:#f92672">&gt;</span> right_executor_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span> result_tuple_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;::</span>const_iterator tuple_iter_;
</span></span></code></pre></td></tr></table>
</div>
</div><p>实现上的大致思路就是首先遍历右表，将tuple存储到HashTable当中。之后再遍历左表，去和右表进行匹配，此时相当于在右表上建立了一个HashIndex，如果匹配成功则将其记录到result_tuple数组当中，如果匹配失败，则去考虑是否为LeftJoin，如果是则添加一条右表为空的记录，先遍历右表的原因也是用于处理LeftJoin</p>
<p>在进行匹配时，需要处理哈希冲突的问题，第一次忘考虑了，出现了9和8300被哈希到了同一个槽当中，之后误匹配上了，解决办法也比较简单，在通过哈希值找到对应的key之后在join前判断一次是否相等即可。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (right_join_key.CompareEquals(join_key) <span style="color:#f92672">==</span> CmpBool<span style="color:#f92672">::</span>CmpTrue)
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后在Next当中通过迭代器去访问result_tuple即可</p>
<p>使用HashJoin进行优化之后，Leaderboard bonus的Q1执行会快上很多，如果不进行优化的话为30000，使用HashJoin可以到80多</p>
<p><img loading="lazy" src="https://pic-bed-1309931445.cos.ap-nanjing.myqcloud.com/blog/20230420002701.png" alt=""  />
</p>
<h2 id="task3">Task3<a hidden class="anchor" aria-hidden="true" href="#task3">#</a></h2>
<p>分别实现<code>sort</code>​ <code>limit</code>​ <code>topN</code>​三个算子以及topn对应的优化，前两个没什么好说，SeqScan修修补补即可。</p>
<h3 id="top-n">Top-N<a hidden class="anchor" aria-hidden="true" href="#top-n">#</a></h3>
<p>Top-N主要针对的为sort+limit的情况，即<code>order by xxx limit n</code>​，这种情况如果不进行优化则需要全表遍历并排序，之后再对排序完的结果进行一次计数截取。</p>
<p>通过Top-N即可保证只有一次全表遍历，计算完之后逐条返回。</p>
<p>根据lab的提示，很容易就可以确立思路，维护一个优先队列，并且保证当中只有K个数据，即通过Next不断获取并插入到其中，如果达到了K个就弹出一个，保证至多有K个</p>
<blockquote>
<p>Think of what data structure can be used to track the top n elements (Andy mentioned it in the lecture). The struct should hold <strong>at most</strong> <code>k</code>​ elements (where <code>k</code>​ is the number specified in <code>LIMIT</code>​ clause).</p>
</blockquote>
<p>不过由于<code>std::priority_queue</code>​当中并没有提供迭代器，也没有提供下标访问，而top访问的是排序最低的那个，因此可以使用一个栈，将整个逻辑进行翻转，从而保证从高向低的进行获取。</p>
<h3 id="top-n-optimizer">Top-N Optimizer<a hidden class="anchor" aria-hidden="true" href="#top-n-optimizer">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> Optimizer<span style="color:#f92672">::</span>Optimize(<span style="color:#66d9ef">const</span> AbstractPlanNodeRef <span style="color:#f92672">&amp;</span>plan) <span style="color:#f92672">-&gt;</span> AbstractPlanNodeRef {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (force_starter_rule_) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use starter rules when `force_starter_rule_` is set to true.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> plan;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> OptimizeMergeProjection(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> OptimizeMergeFilterNLJ(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> OptimizeNLJAsIndexJoin(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> OptimizeOrderByAsIndexScan(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> OptimizeSortLimitAsTopN(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>将原本未经优化的plan树通过多条规则链式的进行优化，最后得到一个最终的优化结果。对于单个的优化方案，都是采用后续遍历的方式，自底向上的改写plan，将符合的类型进行优化。</p>
<p>因此照猫画虎的实现一个，通过Top-N对sort+limit的情况进行优化，只有上层为limit，下层为sort的情况，才将其优化为Top-N。</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>总的来说Lab3的难度并不大，并且在本地提供了全部的测试用例，而且不涉及并发，因此可以安心的单步调试，写起来也就比较的粗放一点，面向bug编程。</p>
<p>整个Lab3做下来给我的感觉是相比于6.830，bustub更注重于深度，在很多地方都提供提供了一定的封装，如磁盘的读写，tuple的读取和写入。虽然少了自行构造table和tuple的过程，对于schema的理解可能差一点，但是在有限的时间内更注重于深度。此外，由于SQL执行这一部分设置在了索引之后，因此在功能的实现上也可以应用索引，如NestedIndexJoin、IndexScan等。在做6.830的基础之上写busTub的话个人感觉会更有收获一点，但是如果只写一个的话，BusTub可能更合适一点，不过需要去阅读一下其他部分的源码，或者像某些佬那样直接自己实现一个BusTub。</p>
<p>最近手头事有点多，也快考试了，整个文章写的比较仓促，Leaderborad bonus暂时也没时间写了，只能先搁置在一边了。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://fischer0522.github.io/en/posts/tech/bustub/bustub-lab4/">
    <span class="title">« Prev</span>
    <br>
    <span>BusTub-Lab4</span>
  </a>
  <a class="next" href="https://fischer0522.github.io/en/posts/tech/bustub/busttub-lab2-c2/">
    <span class="title">Next »</span>
    <br>
    <span>BusTub Lab2 B&#43;Tree Index checkpoint2</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on x"
            href="https://x.com/intent/tweet/?text=BusTub%20Lab3%20Query%20Execution&amp;url=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f&amp;title=BusTub%20Lab3%20Query%20Execution&amp;summary=BusTub%20Lab3%20Query%20Execution&amp;source=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f&title=BusTub%20Lab3%20Query%20Execution">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on whatsapp"
            href="https://api.whatsapp.com/send?text=BusTub%20Lab3%20Query%20Execution%20-%20https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on telegram"
            href="https://telegram.me/share/url?text=BusTub%20Lab3%20Query%20Execution&amp;url=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share BusTub Lab3 Query Execution on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=BusTub%20Lab3%20Query%20Execution&u=https%3a%2f%2ffischer0522.github.io%2fen%2fposts%2ftech%2fbustub%2fbustub-lab3%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://fischer0522.github.io/en/">Fischer&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
